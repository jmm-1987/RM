{% extends "base.html" %}

{% block title %}WhatsApp{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="{{ url_for('static', filename='whatsapp.css') }}">
{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center flex-wrap gap-3 mb-4 header-actions">
    <div>
        <h1 class="h3 mb-1 fw-bold">Bandeja de WhatsApp</h1>
        <p class="text-muted mb-0">Gestiona tus conversaciones y contactos en tiempo real</p>
    </div>
    <div class="d-flex gap-2 flex-wrap">
        <a href="{{ url_for('whatsapp_new_conversation') }}" class="btn btn-success">
            <i class="fas fa-plus"></i> Nueva conversación
        </a>
        <button class="btn btn-outline-success" type="button" id="refresh-conversations">
            <i class="fas fa-sync-alt"></i> Refrescar
        </button>
        <button class="btn btn-outline-primary" type="button" data-bs-toggle="modal" data-bs-target="#contactsModal">
            <i class="fas fa-address-book"></i> Contactos
        </button>
    </div>
</div>

<div class="modal fade" id="contactsModal" tabindex="-1" aria-labelledby="contactsModalLabel" aria-hidden="true" data-bs-backdrop="true" data-bs-keyboard="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable" style="z-index: 1056;">
        <div class="modal-content" style="z-index: 1057; position: relative;">
            <div class="modal-header" style="pointer-events: auto;">
                <h5 class="modal-title" id="contactsModalLabel">Contactos guardados</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Cerrar" style="pointer-events: auto;"></button>
            </div>
            <div class="modal-body" style="pointer-events: auto;">
                <div class="mb-3 d-none" id="contacts-search-wrapper">
                    <div class="input-group">
                        <span class="input-group-text"><i class="fas fa-search"></i></span>
                        <input type="search" class="form-control" id="contacts-search" placeholder="Buscar contacto...">
                    </div>
                </div>
                <div id="contacts-loading" class="text-center my-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Cargando...</span>
                    </div>
                </div>
                <div id="contacts-error" class="alert alert-danger d-none"></div>
                <div id="contacts-table-wrapper" class="table-responsive d-none">
                    <table class="table table-striped table-hover align-middle">
                        <thead>
                            <tr>
                                <th scope="col">Nombre</th>
                                <th scope="col">Chat ID</th>
                                <th scope="col">Tipo</th>
                                <th scope="col">Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="contacts-table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Buscador de conversaciones -->
<div class="mb-3">
    <div class="input-group mb-2">
        <span class="input-group-text" style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: #fff;">
            <i class="fas fa-search"></i>
        </span>
        <input 
            type="search" 
            class="form-control" 
            id="conversation-search" 
            placeholder="Buscar conversación por nombre del cliente..." 
            autocomplete="off"
            style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: #fff;"
        >
        <button 
            class="btn btn-outline-secondary" 
            type="button" 
            id="clear-search"
            style="border-color: rgba(255, 255, 255, 0.2); color: #fff; display: none;"
        >
            <i class="fas fa-times"></i>
        </button>
    </div>
    <div class="d-flex flex-wrap gap-3">
        <div class="form-check">
            <input 
                class="form-check-input" 
                type="checkbox" 
                id="filter-unread" 
                style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);"
            >
            <label class="form-check-label" for="filter-unread" style="color: #fff; cursor: pointer;">
                <i class="fas fa-envelope"></i> Mostrar solo conversaciones con mensajes no leídos
            </label>
        </div>
        <div class="form-check">
            <input 
                class="form-check-input" 
                type="checkbox" 
                id="filter-administracion" 
                style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);"
            >
            <label class="form-check-label" for="filter-administracion" style="color: #fff; cursor: pointer;">
                <i class="fas fa-briefcase"></i> Mostrar solo conversaciones de administración
            </label>
        </div>
    </div>
</div>

<div id="conversation-list-wrapper" class="{% if not conversaciones %}d-none{% endif %}">
    <div id="conversation-list" class="conversation-grid">
        {% for conversation in conversaciones %}
            {% set last = conversation._last_message %}
            {% set unread = conversation._unread_count %}
            <div class="conversation-tile-wrapper position-relative">
                <a class="conversation-tile" href="{{ url_for('whatsapp_conversation_detail', conversation_id=conversation.id) }}">
                    <div class="tile-header d-flex justify-content-between align-items-center">
                        <div class="d-flex align-items-center gap-2 flex-grow-1">
                            <div class="tile-name">{{ conversation.contact_name or conversation.contact_number|chat_display }}</div>
                            {% if conversation.tipo == 'administracion' %}
                                <span class="badge bg-warning text-dark" style="font-size: 0.7rem;">
                                    <i class="fas fa-briefcase"></i> Administración
                                </span>
                            {% endif %}
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            {% set last_agent = conversation._last_agent_message %}
                            {% if last_agent and last_agent.usuario %}
                                <span class="badge" style="background-color: {{ last_agent.usuario.color or '#007bff' }}; color: white; font-size: 0.75rem;">
                                    <i class="fas fa-user"></i> Último usuario: {{ last_agent.usuario.username }}
                                </span>
                            {% endif %}
                            <div class="tile-meta">
                                {{ (conversation.updated_at | local_time).strftime("%d/%m/%Y %H:%M") if conversation.updated_at else "" }}
                            </div>
                        </div>
                    </div>
                    {% if conversation.anotaciones %}
                    <div class="tile-anotaciones mb-2" style="font-size: 0.85rem; color: #ffc107; font-style: italic; padding: 0.25rem 0.5rem; background: rgba(255, 193, 7, 0.1); border-radius: 4px;">
                        <i class="fas fa-sticky-note"></i> {{ conversation.anotaciones[:100] }}{% if conversation.anotaciones|length > 100 %}...{% endif %}
                    </div>
                    {% endif %}
                    <div class="tile-snippet">
                        {% if last %}
                            {% if last.sender_type == 'agent' %}
                                {% if last.usuario %}
                                    {% set prefix = last.usuario.username ~ ':' %}
                                {% else %}
                                    {% set prefix = 'Sistema:' %}
                                {% endif %}
                            {% else %}
                                {% set prefix = (conversation.contact_name or conversation.contact_number|chat_display) ~ ':' %}
                            {% endif %}
                            {% if last.message_text %}
                                {{ prefix }} {{ last.message_text }}
                            {% elif last.media_type %}
                                {{ prefix }} [{{ last.media_type|title }}]
                            {% else %}
                                {{ prefix }} Mensaje
                            {% endif %}
                        {% else %}
                            Sin mensajes todavía
                        {% endif %}
                    </div>
                    {% if unread %}
                    <div class="tile-footer mt-2">
                        <span class="badge bg-danger">{{ unread }} sin leer</span>
                    </div>
                    {% endif %}
                </a>
                <div class="tile-actions position-absolute top-0 end-0 p-2" style="z-index: 10;" onclick="event.stopPropagation();">
                    <div class="btn-group-vertical btn-group-sm">
                        <button 
                            class="btn btn-sm btn-outline-warning" 
                            type="button"
                            onclick="event.preventDefault(); editarAnotaciones({{ conversation.id }}, {{ (conversation.anotaciones or '')|tojson }});"
                            title="Editar anotaciones"
                            style="padding: 0.25rem 0.5rem;"
                        >
                            <i class="fas fa-sticky-note"></i>
                        </button>
                        <button 
                            class="btn btn-sm {{ 'btn-warning' if conversation.tipo == 'administracion' else 'btn-outline-secondary' }}" 
                            type="button"
                            onclick="event.preventDefault(); toggleTipoAdministracion({{ conversation.id }}, {{ 'true' if conversation.tipo == 'administracion' else 'false' }});"
                            title="{{ 'Quitar tipo administración' if conversation.tipo == 'administracion' else 'Marcar como administración' }}"
                            style="padding: 0.25rem 0.5rem;"
                        >
                            <i class="fas fa-briefcase"></i>
                        </button>
                    </div>
                </div>
            </div>
        {% endfor %}
    </div>
</div>

<div id="conversation-empty" class="empty-state {% if conversaciones %}d-none{% endif %}">
    <i class="fab fa-whatsapp fa-3x text-success mb-3"></i>
    <h5 class="fw-semibold mb-2">Aún no hay conversaciones</h5>
    <p class="text-muted mb-3">Inicia una conversación con el botón verde o espera a que llegue un nuevo mensaje.</p>
    <a href="{{ url_for('whatsapp_new_conversation') }}" class="btn btn-success">
        <i class="fas fa-plus"></i> Nueva conversación
    </a>
</div>

<script>
(function() {
    const listWrapper = document.getElementById("conversation-list-wrapper");
    const listElement = document.getElementById("conversation-list");
    const emptyAlert = document.getElementById("conversation-empty");
    const searchInput = document.getElementById("conversation-search");
    const clearSearchBtn = document.getElementById("clear-search");
    const filterUnreadCheckbox = document.getElementById("filter-unread");
    const filterAdministracionCheckbox = document.getElementById("filter-administracion");
    
    let allConversations = []; // Almacenar todas las conversaciones para filtrar

    if (!listElement) {
        return;
    }

    const apiUrl = "{{ url_for('whatsapp_api_conversations') }}";
    
    // Inicializar allConversations con las conversaciones del DOM inicial si existen
    // Esto permite que los filtros funcionen inmediatamente al cargar la página
    function initializeConversationsFromDOM() {
        const tiles = listElement.querySelectorAll('.conversation-tile-wrapper');
        if (tiles.length === 0) return;
        
        const conversations = [];
        tiles.forEach((tile) => {
            const link = tile.querySelector('.conversation-tile');
            if (!link) return;
            
            const href = link.getAttribute('href');
            const match = href.match(/\/whatsapp\/conversaciones\/(\d+)/);
            if (!match) return;
            
            const conversationId = parseInt(match[1]);
            const nameElement = link.querySelector('.tile-name');
            const displayName = nameElement ? nameElement.textContent.trim() : '';
            
            // Verificar si tiene badge de administración
            const adminBadge = link.querySelector('.badge.bg-warning.text-dark');
            const tipo = adminBadge ? 'administracion' : null;
            
            // Verificar si tiene anotaciones
            const anotacionesElement = link.querySelector('.tile-anotaciones');
            let anotaciones = '';
            if (anotacionesElement) {
                const text = anotacionesElement.textContent || anotacionesElement.innerText || '';
                anotaciones = text.replace(/.*?fa-sticky-note.*?\s+/, '').trim();
            }
            
            // Verificar mensajes no leídos
            const unreadBadge = link.querySelector('.badge.bg-danger');
            const unreadCount = unreadBadge ? parseInt((unreadBadge.textContent || '0').match(/\d+/)?.[0] || '0') : 0;
            
            // Obtener último mensaje
            const snippetElement = link.querySelector('.tile-snippet');
            const lastMessageText = snippetElement ? (snippetElement.textContent || snippetElement.innerText || '').trim() : '';
            
            // Obtener fecha
            const metaElement = link.querySelector('.tile-meta');
            const updatedAtHuman = metaElement ? (metaElement.textContent || metaElement.innerText || '').trim() : '';
            
            conversations.push({
                id: conversationId,
                display_name: displayName,
                tipo: tipo,
                anotaciones: anotaciones,
                unread_count: unreadCount,
                last_message_text: lastMessageText,
                updated_at_human: updatedAtHuman,
                url: href
            });
        });
        
        if (conversations.length > 0) {
            allConversations = conversations;
        }
    }
    
    // Inicializar conversaciones desde el DOM si existen
    initializeConversationsFromDOM();

    function renderConversations(items) {
        if (!items.length) {
            if (listWrapper) {
                listWrapper.classList.add("d-none");
            }
            if (emptyAlert) {
                emptyAlert.classList.remove("d-none");
            }
            listElement.innerHTML = "";
            return;
        }

        if (listWrapper) {
            listWrapper.classList.remove("d-none");
        }
        if (emptyAlert) {
            emptyAlert.classList.add("d-none");
        }

        listElement.innerHTML = "";

        items.forEach((item) => {
            const wrapper = document.createElement("div");
            wrapper.className = "conversation-tile-wrapper position-relative";
            
            const link = document.createElement("a");
            link.className = "conversation-tile";
            link.href = item.url;

            const header = document.createElement("div");
            header.className = "tile-header d-flex justify-content-between align-items-center";

            const leftSide = document.createElement("div");
            leftSide.className = "d-flex align-items-center gap-2 flex-grow-1";
            
            const name = document.createElement("div");
            name.className = "tile-name";
            name.textContent = item.display_name;
            leftSide.appendChild(name);
            
            // Badge de tipo administración
            if (item.tipo === 'administracion') {
                const tipoBadge = document.createElement("span");
                tipoBadge.className = "badge bg-warning text-dark";
                tipoBadge.style.fontSize = "0.7rem";
                tipoBadge.innerHTML = '<i class="fas fa-briefcase"></i> Administración';
                leftSide.appendChild(tipoBadge);
            }

            const rightSide = document.createElement("div");
            rightSide.className = "d-flex align-items-center gap-2";

            // Añadir badge del último usuario del sistema que habló (siempre mostrar, incluso si el último mensaje es del cliente)
            if (item.last_usuario) {
                const userBadge = document.createElement("span");
                userBadge.className = "badge";
                // Usar el color del usuario directamente de su ficha
                userBadge.style.backgroundColor = item.last_usuario.color || "#007bff";
                userBadge.style.color = "white";
                userBadge.style.fontSize = "0.75rem";
                userBadge.innerHTML = `<i class="fas fa-user"></i> Último usuario: ${item.last_usuario.username}`;
                rightSide.appendChild(userBadge);
            }

            const meta = document.createElement("div");
            meta.className = "tile-meta";
            meta.textContent = item.updated_at_human || "";
            rightSide.appendChild(meta);

            header.appendChild(leftSide);
            header.appendChild(rightSide);

            // Añadir anotaciones si existen
            if (item.anotaciones) {
                const anotacionesDiv = document.createElement("div");
                anotacionesDiv.className = "tile-anotaciones mb-2";
                anotacionesDiv.style.cssText = "font-size: 0.85rem; color: #ffc107; font-style: italic; padding: 0.25rem 0.5rem; background: rgba(255, 193, 7, 0.1); border-radius: 4px;";
                const anotacionesText = item.anotaciones.length > 100 ? item.anotaciones.substring(0, 100) + '...' : item.anotaciones;
                anotacionesDiv.innerHTML = `<i class="fas fa-sticky-note"></i> ${anotacionesText}`;
                link.appendChild(anotacionesDiv);
            }

            const snippet = document.createElement("div");
            snippet.className = "tile-snippet";

            const prefix = item.last_message_sender === "agent"
                ? (item.last_usuario ? item.last_usuario.username + ": " : "Sistema: ")
                : `${item.display_name}: `;

            if (item.last_message_text) {
                snippet.textContent = prefix + item.last_message_text;
            } else if (item.last_media_type) {
                const mediaLabels = {
                    imagen: "[Imagen]",
                    video: "[Video]",
                    audio: "[Audio]",
                    documento: "[Documento]",
                    adjunto: "[Adjunto]"
                };
                snippet.textContent = prefix + (mediaLabels[item.last_media_type] || "[Contenido multimedia]");
            } else {
                snippet.textContent = "Sin mensajes todavía";
            }

            link.appendChild(header);
            link.appendChild(snippet);

            // Añadir badge de mensajes sin leer si hay
            if (item.unread_count) {
                const footer = document.createElement("div");
                footer.className = "tile-footer mt-2";
                const unreadBadge = document.createElement("span");
                unreadBadge.className = "badge bg-danger";
                unreadBadge.textContent = `${item.unread_count} sin leer`;
                footer.appendChild(unreadBadge);
                link.appendChild(footer);
            }
            
            // Botones de acción
            const actionsDiv = document.createElement("div");
            actionsDiv.className = "tile-actions position-absolute top-0 end-0 p-2";
            actionsDiv.style.zIndex = "10";
            actionsDiv.onclick = (e) => e.stopPropagation();
            
            const btnGroup = document.createElement("div");
            btnGroup.className = "btn-group-vertical btn-group-sm";
            
            // Botón editar anotaciones
            const btnAnotaciones = document.createElement("button");
            btnAnotaciones.className = "btn btn-sm btn-outline-warning";
            btnAnotaciones.type = "button";
            btnAnotaciones.style.padding = "0.25rem 0.5rem";
            btnAnotaciones.title = "Editar anotaciones";
            btnAnotaciones.innerHTML = '<i class="fas fa-sticky-note"></i>';
            btnAnotaciones.onclick = (e) => {
                e.preventDefault();
                editarAnotaciones(item.id, item.anotaciones || '');
            };
            
            // Botón toggle tipo administración
            const btnTipo = document.createElement("button");
            const esAdmin = item.tipo === 'administracion' || item.tipo === 'administración';
            btnTipo.className = esAdmin ? "btn btn-sm btn-warning" : "btn btn-sm btn-outline-secondary";
            btnTipo.type = "button";
            btnTipo.style.padding = "0.25rem 0.5rem";
            btnTipo.title = esAdmin ? "Quitar tipo administración" : "Marcar como administración";
            btnTipo.innerHTML = '<i class="fas fa-briefcase"></i>';
            btnTipo.onclick = (e) => {
                e.preventDefault();
                toggleTipoAdministracion(item.id, esAdmin);
            };
            
            btnGroup.appendChild(btnAnotaciones);
            btnGroup.appendChild(btnTipo);
            actionsDiv.appendChild(btnGroup);
            
            wrapper.appendChild(link);
            wrapper.appendChild(actionsDiv);
            listElement.appendChild(wrapper);
        });
    }

    function fetchConversations() {
        // Guardar el estado actual de los filtros antes de recargar
        const unreadFilterActive = filterUnreadCheckbox ? filterUnreadCheckbox.checked : false;
        const administracionFilterActive = filterAdministracionCheckbox ? filterAdministracionCheckbox.checked : false;
        const searchTerm = searchInput ? searchInput.value : '';
        
        fetch(apiUrl)
            .then((response) => {
                if (!response.ok) {
                    throw new Error("No fue posible actualizar la bandeja");
                }
                return response.json();
            })
            .then((payload) => {
                if (Array.isArray(payload.conversations)) {
                    allConversations = payload.conversations; // Guardar todas las conversaciones
                    
                    // Restaurar el estado de los filtros
                    if (filterUnreadCheckbox) {
                        filterUnreadCheckbox.checked = unreadFilterActive;
                    }
                    if (filterAdministracionCheckbox) {
                        filterAdministracionCheckbox.checked = administracionFilterActive;
                    }
                    if (searchInput) {
                        searchInput.value = searchTerm;
                    }
                    
                    // Aplicar filtros con el estado restaurado
                    filterConversations();
                }
            })
            .catch((error) => console.error(error));
    }

    function filterConversations() {
        let filtered = allConversations;
        
        // Filtrar por término de búsqueda
        if (searchInput) {
            const searchTerm = searchInput.value.toLowerCase().trim();
            
            // Mostrar/ocultar botón de limpiar búsqueda
            if (searchTerm) {
                clearSearchBtn.style.display = 'block';
            } else {
                clearSearchBtn.style.display = 'none';
            }
            
            if (searchTerm) {
                // Filtrar conversaciones por nombre del cliente
                filtered = filtered.filter(conversation => {
                    const displayName = (conversation.display_name || '').toLowerCase();
                    return displayName.includes(searchTerm);
                });
            }
        }
        
        // Filtrar por mensajes no leídos si el checkbox está activado
        if (filterUnreadCheckbox && filterUnreadCheckbox.checked) {
            filtered = filtered.filter(conversation => {
                return conversation.unread_count && conversation.unread_count > 0;
            });
        }
        
        // Filtrar por tipo administración si el checkbox está activado
        if (filterAdministracionCheckbox && filterAdministracionCheckbox.checked) {
            filtered = filtered.filter(conversation => {
                return conversation.tipo === 'administracion';
            });
        }
        
        renderConversations(filtered);
    }

    // Búsqueda dinámica con debounce para mejor rendimiento
    let searchTimeout;
    if (searchInput) {
        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(function() {
                filterConversations();
            }, 300); // Esperar 300ms después de que el usuario deje de escribir
        });
        
        searchInput.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                searchInput.value = '';
                filterConversations();
                searchInput.blur();
            }
        });
    }

    // Botón para limpiar búsqueda
    if (clearSearchBtn) {
        clearSearchBtn.addEventListener('click', function() {
            if (searchInput) {
                searchInput.value = '';
                filterConversations();
                searchInput.focus();
            }
        });
    }

    // Checkbox para filtrar solo no leídos
    if (filterUnreadCheckbox) {
        filterUnreadCheckbox.addEventListener('change', function() {
            filterConversations();
        });
    }
    
    // Checkbox para filtrar solo administración
    if (filterAdministracionCheckbox) {
        filterAdministracionCheckbox.addEventListener('change', function() {
            filterConversations();
        });
    }

    // Cargar conversaciones inmediatamente al cargar la página
    // Esto asegura que allConversations esté poblado antes de aplicar filtros
    fetchConversations();
    
    setInterval(fetchConversations, 12000); // Reducido de 5s a 12s para mejor rendimiento
    const refreshBtn = document.getElementById("refresh-conversations");
    if (refreshBtn) {
        refreshBtn.addEventListener("click", () => {
            fetchConversations();
        });
    }

    const contactsModal = document.getElementById("contactsModal");
    if (!contactsModal) {
        return;
    }

    const contactsLoading = document.getElementById("contacts-loading");
    const contactsError = document.getElementById("contacts-error");
    const contactsWrapper = document.getElementById("contacts-table-wrapper");
    const contactsTableBody = document.getElementById("contacts-table-body");
    const contactsSearchWrapper = document.getElementById("contacts-search-wrapper");
    const contactsSearch = document.getElementById("contacts-search");
    let cachedContacts = [];

    function renderContacts(contacts) {
        contactsTableBody.innerHTML = "";

        if (!contacts.length) {
            const row = document.createElement("tr");
            const cell = document.createElement("td");
            cell.colSpan = 4;
            cell.className = "text-center text-muted";
            cell.textContent = "Twilio no proporciona una API de contactos. Los contactos se gestionan desde la base de datos de clientes.";
            row.appendChild(cell);
            contactsTableBody.appendChild(row);
            return;
        }

        contacts.forEach((contact) => {
            const row = document.createElement("tr");

            const nameCell = document.createElement("td");
            nameCell.textContent = (contact.name || "").trim() || contact.chat_id || "Sin nombre";

            const idCell = document.createElement("td");
            idCell.textContent = contact.chat_id || "";

            const typeCell = document.createElement("td");
            typeCell.textContent = contact.type || "-";

            const actionsCell = document.createElement("td");
            const button = document.createElement("button");
            button.type = "button";
            button.className = "btn btn-sm btn-outline-success";
            button.textContent = "Abrir";
            button.addEventListener("click", () => {
                const phone = contact.chat_id ? contact.chat_id.replace(/@.*/, "") : "";
                if (phone) {
                    window.location.href = "{{ url_for('whatsapp_new_conversation') }}" + "?number=" + encodeURIComponent(phone);
                } else {
                    alert("No se puede iniciar conversación: falta el chatId");
                }
            });
            actionsCell.appendChild(button);

            row.appendChild(nameCell);
            row.appendChild(idCell);
            row.appendChild(typeCell);
            row.appendChild(actionsCell);

            contactsTableBody.appendChild(row);
        });
    }

    contactsModal.addEventListener("show.bs.modal", function () {
        contactsLoading.classList.remove("d-none");
        contactsError.classList.add("d-none");
        contactsWrapper.classList.add("d-none");
            contactsSearchWrapper.classList.add("d-none");
            contactsSearch.value = "";
            cachedContacts = [];

        fetch("{{ url_for('whatsapp_api_contacts') }}")
            .then((response) => {
                if (!response.ok) {
                    throw new Error("No se pudo obtener la lista de contactos");
                }
                return response.json();
            })
            .then((payload) => {
                cachedContacts = Array.isArray(payload.contacts) ? payload.contacts : [];
                renderContacts(cachedContacts);
                contactsWrapper.classList.remove("d-none");
                contactsSearchWrapper.classList.remove("d-none");
            })
            .catch((error) => {
                contactsError.textContent = error.message;
                contactsError.classList.remove("d-none");
            })
            .finally(() => {
                contactsLoading.classList.add("d-none");
            });
    });

    if (contactsSearch) {
        contactsSearch.addEventListener("input", function () {
            const term = this.value.toLowerCase().trim();
            if (!term) {
                renderContacts(cachedContacts);
                return;
            }

            const filtered = cachedContacts.filter(contact => {
                const name = (contact.name || "").toLowerCase();
                const chatId = (contact.chat_id || "").toLowerCase();
                return name.includes(term) || chatId.includes(term);
            });

            renderContacts(filtered);
        });
    }
})();

// Funciones globales para editar anotaciones y tipo
function editarAnotaciones(conversationId, anotacionesActuales) {
    const anotaciones = prompt('Editar anotaciones:', anotacionesActuales || '');
    if (anotaciones === null) return; // Usuario canceló
    
    fetch(`/whatsapp/api/conversaciones/${conversationId}/anotaciones`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            anotaciones: anotaciones.trim()
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Recargar las conversaciones (fetchConversations ya mantiene el estado de los filtros)
            const refreshBtn = document.getElementById("refresh-conversations");
            if (refreshBtn) {
                refreshBtn.click();
            }
        } else {
            alert('Error: ' + (data.error || 'No se pudieron actualizar las anotaciones'));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error al actualizar las anotaciones');
    });
}

function toggleTipoAdministracion(conversationId, esAdministracion) {
    const nuevoTipo = esAdministracion ? null : 'administracion';
    
    // Guardar estado de filtros antes de recargar
    const unreadFilterActive = document.getElementById("filter-unread") ? document.getElementById("filter-unread").checked : false;
    const administracionFilterActive = document.getElementById("filter-administracion") ? document.getElementById("filter-administracion").checked : false;
    const searchTerm = document.getElementById("conversation-search") ? document.getElementById("conversation-search").value : '';
    
    fetch(`/whatsapp/api/conversaciones/${conversationId}/tipo`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            tipo: nuevoTipo
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Recargar las conversaciones manteniendo los filtros
            const refreshBtn = document.getElementById("refresh-conversations");
            if (refreshBtn) {
                // Simular click pero mantener estado
                const event = new Event('click');
                refreshBtn.dispatchEvent(event);
            } else {
                // Si no hay botón, recargar directamente
                location.reload();
            }
        } else {
            alert('Error: ' + (data.error || 'No se pudo actualizar el tipo de conversación'));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error al actualizar el tipo de conversación');
    });
}
</script>
{% endblock %}

